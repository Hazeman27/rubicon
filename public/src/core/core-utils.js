export class FilePathRegExp extends RegExp {
	/** @type {string[]} */
	_extensions = [];

	/**
	 * @param {string} pattern The text of the regular expression.
	 * @param {string[]} extensions Array of extensions to match. Without preceding dot.
 	 * For example: `js, ts` are valid arguments while `.js, .ts` are not.
	 * @param {string} [flags] If specified, flags is a string that contains the
	 * flags to add.
	 */
	constructor(pattern, extensions, flags) {
		super(pattern, flags);
		this._extensions = extensions;
	}

	get extensions() {
		return this._extensions;
	}
}

/**
 * @param {string[]} extensions
 * @param {string} [separator=|]
 * @returns {string[]}
 */
function _createExtRegExpString(extensions, separator = '|') {
	return extensions.map(extension => `.${extension}`).join(separator);
}

/**
 * @typedef {object} FilePathRegExpOptions
 * @property {string} flags
 * @property {boolean} backslash
 */

/**
 * Generates regular expression that matches path strings with specified file
 * extensions.
 *
 * @param {string[]} extensions Array of extensions to match. Without preceding dot.
 * For example: `js, ts` are valid arguments while `.js, .ts` are not.
 * @param {FilePathRegExpOptions} [options]
 * @returns {FilePathRegExp}
 */
export function generateFilePathRegExp(
	extensions,
	{ flags = '', backslash = false } = { flags: '', backslash: false }
) {
	const slash = backslash ? '\\' : '/';

	return new FilePathRegExp(
		`(.*${slash})?(.+)(?=(${_createExtRegExpString(extensions)}))`,
		extensions,
		flags
	);
}

/**
 * @typedef {object} FilePathInfo Contains information about the current file path.
 * @property {string} fullPath Absolute path to the current file.
 * @property {string} fullPathNoExtension Absolute path to the current file without
 * file extension.
 * @property {string} directoryPath Absolute path to the current directory.
 * @property {string} fileName Name of the current file, no extension.
 * @property {string} fileExtension Extension of the current file.
 */

/**
 * @param {string} path
 * @param {FilePathRegExp} regex
 * @returns {FilePathInfo}
 */
export function extractFilePathInfo(path, regex) {
	const [
		fullPathNoExtension,
		directoryPath,
		fileName,
		fileExtension
	] = path.match(regex);

	return {
		fullPath: `${fullPathNoExtension}${fileExtension}`,
		fullPathNoExtension,
		directoryPath,
		fileName,
		fileExtension
	};
}

/**
 * @param {string[]} expectedExtensions Array of expected extensions without
 * preceding dot.
 * @param {string} receivedExtension
 */
export function generateFileExtErrorMessages(expectedExtensions, receivedExtension) {
	const extensions = _createExtRegExpString(expectedExtensions, ' or ');
	return [
		'Incorrect file extension!',
		`Expected ${extensions}, but got ${receivedExtension}.`
	];
}

/**
 * Logs error messages generated based on expected and received file types using
 * specified logger function.
 *
 * @param {string} path File path that caused error.
 * @param {FilePathRegExp} regex Regular expression used to match file path that
 * was generated by @see generateFilePathRegExp function.
 * @param {(...any)} [logger=console.error] Logging function.
 */
export function logFileExtErrorMessages(
	path,
	regex,
	logger = console.error
) {
	const pathInfo = extractFilePathInfo(path, regex);

	generateFileExtErrorMessages(
		regex.extensions,
		pathInfo.fileExtension
	).forEach(logger);
}

/**
 * Capitalizes first letter of the string.
 * @param {string} string
 */
export function capitalize(string) {
	return `${string[0].toUpperCase()}${string.slice(1)}`;
}

/** @param {string} fileName */
export function getBasename(fileName) {
	return fileName.match(/[\w0-9-_]+(?=\.[\w0-9]+$)/)[0];
}

/** @param {CustomElementConstructor} constructor */
export function generateCustomElementName(constructor) {
	return constructor.name
		.split('')
		.map((char, index, array) => {
			const lowerCase = char.toLowerCase();
			const upperCase = char.toUpperCase();

			const previous = index > 0 ? array[index - 1] : '';
			const next = index < array.length - 1 ? array[index + 1] : '';

			const isNotFirst = index > 0;
			const isUpperCase = char === upperCase;
			const previousIsUpperCase = previous === previous.toUpperCase();
			const nextIsUpperCase = next === next.toUpperCase();

			if (isNotFirst && isUpperCase && !(previousIsUpperCase && nextIsUpperCase))
				return `-${lowerCase}`;

			return lowerCase;
		}).join('');
}
